<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OpenClaw Agent Hub</title>
  <style>
    :root {
      --bg: #8f8f8f;
      --gridA: #8a8a8a;
      --gridB: #7f7f7f;
      --zone: #d8d8d8;
      --zoneLine: #b9b9b9;
      --panel: rgba(14, 14, 14, 0.86);
      --text: #ededed;
      --muted: #b9b9b9;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    #app { position: fixed; inset: 0; }
    #terminal {
      position: fixed; top: 10px; left: 10px; width: 390px; z-index: 20;
      background: var(--panel); border: 1px solid #373737; border-radius: 10px;
      padding: 10px; color: var(--text); backdrop-filter: blur(2px);
    }
    #termTitle { font-size: 12px; letter-spacing: .08em; font-weight: 700; }
    #termMeta { margin-top: 4px; color: var(--muted); font-size: 11px; }
    #cmdRow { display: flex; gap: 8px; margin-top: 8px; }
    #cmd { flex: 1; background: #0e0e0e; border: 1px solid #3c3c3c; color: #f2f2f2; border-radius: 7px; padding: 8px; font-size: 12px; }
    #run { background: #161616; border: 1px solid #454545; color: #f2f2f2; border-radius: 7px; padding: 8px 11px; cursor: pointer; font-size: 12px; }
    #out { margin-top: 8px; font-size: 11px; color: #d3d3d3; min-height: 14px; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="terminal">
    <div id="termTitle">OPENCLAW AGENT HUB</div>
    <div id="termMeta">Humans observe, agents act. Commands: /FOCUS /TASK /STATUS</div>
    <div id="cmdRow">
      <input id="cmd" placeholder="/FOCUS /TASK/ASSIGN or /TASK CLAW-014 optimize-path" />
      <button id="run">RUN</button>
    </div>
    <div id="out">Booted. Distributed cognition online.</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.167.1/build/three.module.js';

    const ZONES = [
      '/AGENTS/STATUS', '/AGENTS/DEPLOY', '/TASK/ASSIGN', '/SIMULATION', '/EVALUATION',
      '/OPTIMIZATION', '/REPUTATION', '/MARKETPLACE', '/GATEWAY', '/ARCHIVE'
    ];
    const STATUS_LIST = ['idle', 'executing', 'syncing', 'error'];
    const STATUS_COLOR = { idle: 0x9ca3af, executing: 0x10b981, syncing: 0x3b82f6, error: 0xef4444 };

    const app = document.getElementById('app');
    const out = document.getElementById('out');
    const cmd = document.getElementById('cmd');
    const run = document.getElementById('run');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x8f8f8f);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const cam = new THREE.OrthographicCamera();
    let zoom = 1;
    const camTarget = new THREE.Vector3(0, 0, 0);
    const camLook = new THREE.Vector3(0, 0, 0);
    let yaw = Math.PI / 4;

    function updateCamFrustum() {
      const aspect = innerWidth / innerHeight;
      const fr = 92 / zoom;
      cam.left = (-fr * aspect) / 2;
      cam.right = (fr * aspect) / 2;
      cam.top = fr / 2;
      cam.bottom = -fr / 2;
      cam.near = 0.1;
      cam.far = 2000;
      cam.updateProjectionMatrix();
    }
    updateCamFrustum();

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const d = new THREE.DirectionalLight(0xffffff, 0.45);
    d.position.set(40, 90, 20);
    scene.add(d);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(1800, 1800), new THREE.MeshLambertMaterial({ color: 0x949494 }));
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    scene.add(new THREE.GridHelper(640, 128, 0x838383, 0x8f8f8f));

    const zoneObjects = [];
    const zoneMap = new Map();

    function makeTextCanvas(text, w = 720, h = 130, bg = '#101010', fg = '#ffffff', font = 'bold 56px monospace') {
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const x = c.getContext('2d');
      x.fillStyle = bg; x.fillRect(0, 0, w, h);
      x.fillStyle = fg; x.font = font; x.textAlign = 'center'; x.textBaseline = 'middle';
      x.fillText(text, w / 2, h / 2 + 1);
      return c;
    }

    function makeZoneLabel(path) {
      const tex = new THREE.CanvasTexture(makeTextCanvas(path));
      const m = new THREE.Mesh(new THREE.PlaneGeometry(16, 2.8), new THREE.MeshBasicMaterial({ map: tex }));
      m.rotation.x = -Math.PI / 8;
      m.userData.path = path;
      return m;
    }

    function addZone(path, x, z) {
      const g = new THREE.Group();
      g.position.set(x, 0, z);

      const floor = new THREE.Mesh(new THREE.BoxGeometry(30, 0.24, 22), new THREE.MeshLambertMaterial({ color: 0xd8d8d8 }));
      floor.position.y = 0.12;
      g.add(floor);

      const wallMat = new THREE.MeshLambertMaterial({ color: 0xe3e3e3 });
      const left = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 22), wallMat); left.position.set(-15, 2, 0);
      const right = left.clone(); right.position.x = 15;
      const back = new THREE.Mesh(new THREE.BoxGeometry(30, 4, 1), wallMat); back.position.set(0, 2, -11);
      g.add(left, right, back);

      const edge = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(30, 4, 22)),
        new THREE.LineBasicMaterial({ color: 0xb8b8b8 })
      );
      edge.position.y = 2;
      g.add(edge);

      const label = makeZoneLabel(path);
      label.position.set(0, 5.9, -9.5);
      g.add(label);
      zoneObjects.push(label);

      scene.add(g);
      zoneMap.set(path.toUpperCase(), { x, z });
    }

    const layout = [
      [-64, -28], [-20, -28], [24, -28], [68, -28],
      [-64, 10],  [-20, 10],  [24, 10],  [68, 10],
      [2, 48],    [46, 48]
    ];
    ZONES.forEach((z, i) => addZone(z, layout[i][0], layout[i][1]));

    // corridors
    const cMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    const c1 = new THREE.Mesh(new THREE.BoxGeometry(170, 0.12, 16), cMat); c1.position.set(2, 0.06, -28);
    const c2 = new THREE.Mesh(new THREE.BoxGeometry(170, 0.12, 16), cMat); c2.position.set(2, 0.06, 10);
    const c3 = new THREE.Mesh(new THREE.BoxGeometry(16, 0.12, 122), cMat); c3.position.set(2, 0.06, 8);
    const c4 = new THREE.Mesh(new THREE.BoxGeometry(88, 0.12, 16), cMat); c4.position.set(24, 0.06, 48);
    scene.add(c1, c2, c3, c4);

    const pathNodes = [
      new THREE.Vector3(-82,0,-28), new THREE.Vector3(2,0,-28), new THREE.Vector3(86,0,-28),
      new THREE.Vector3(-82,0,10), new THREE.Vector3(2,0,10), new THREE.Vector3(86,0,10),
      new THREE.Vector3(2,0,-54), new THREE.Vector3(2,0,64), new THREE.Vector3(24,0,48), new THREE.Vector3(68,0,48)
    ];

    function idLabel(id, status) {
      const text = `${id} [${status}]`;
      const tex = new THREE.CanvasTexture(makeTextCanvas(text, 330, 64, 'rgba(0,0,0,0.72)', '#f4f4f4', 'bold 28px monospace'));
      const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
      sp.scale.set(6.6, 1.3, 1);
      return sp;
    }

    function createAgent(i, moving = true) {
      const id = `CLAW-${String(i + 1).padStart(3, '0')}`;
      const status = STATUS_LIST[(Math.random() * STATUS_LIST.length) | 0];

      const group = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.32, 0.9, 4, 8), new THREE.MeshLambertMaterial({ color: 0x2f2f2f }));
      body.position.y = 0.95;
      const core = new THREE.Mesh(new THREE.SphereGeometry(0.19, 10, 10), new THREE.MeshBasicMaterial({ color: STATUS_COLOR[status] }));
      core.position.set(0, 1.38, 0.28);
      const tag = idLabel(id, status);
      tag.position.set(0, 2.4, 0);
      group.add(body, core, tag);

      const start = moving ? pathNodes[(Math.random() * pathNodes.length) | 0] : new THREE.Vector3(
        layout[i % layout.length][0] + (Math.random() - 0.5) * 8,
        0,
        layout[i % layout.length][1] + (Math.random() - 0.5) * 6
      );
      group.position.copy(start);
      scene.add(group);

      return {
        id,
        status,
        task: 'monitor',
        moving,
        mesh: group,
        tag,
        target: pathNodes[(Math.random() * pathNodes.length) | 0].clone(),
        speed: 1.2 + Math.random() * 1.2,
        pause: Math.random() * 1.4
      };
    }

    const agents = [];
    for (let i = 0; i < 140; i++) agents.push(createAgent(i, i > 35));

    let selectedAgent = null;
    const agentPickMeshes = agents.map(a => a.mesh);

    function focusZone(path) {
      const z = zoneMap.get(path.toUpperCase());
      if (!z) return false;
      camTarget.set(z.x + 22, 0, z.z + 22);
      camLook.set(z.x, 0, z.z);
      out.textContent = `Focused ${path}`;
      return true;
    }

    function setAgentTask(id, task) {
      const a = agents.find(x => x.id === id);
      if (!a) return false;
      a.task = task;
      selectedAgent = a;
      out.textContent = `${id} -> task: ${task}`;
      return true;
    }

    function runCommand(raw) {
      const line = String(raw || '').trim();
      if (!line) return;
      const upper = line.toUpperCase();

      if (zoneMap.has(upper)) return focusZone(upper);
      if (upper.startsWith('/FOCUS ')) {
        const zone = line.slice(7).trim();
        return focusZone(zone) || (out.textContent = `Unknown zone: ${zone}`);
      }
      if (upper.startsWith('/TASK ')) {
        const parts = line.split(/\s+/);
        if (parts.length < 3) return out.textContent = 'Usage: /TASK CLAW-014 optimize-route';
        const id = parts[1].toUpperCase();
        const task = parts.slice(2).join(' ');
        return setAgentTask(id, task) || (out.textContent = `Unknown agent: ${id}`);
      }
      if (upper === '/STATUS') {
        const counts = { idle:0, executing:0, syncing:0, error:0 };
        agents.forEach(a => counts[a.status]++);
        out.textContent = `idle:${counts.idle} executing:${counts.executing} syncing:${counts.syncing} error:${counts.error}`;
        return;
      }
      out.textContent = `Unknown command: ${line}`;
    }

    run.onclick = () => runCommand(cmd.value);
    cmd.addEventListener('keydown', e => e.key === 'Enter' && runCommand(cmd.value));

    const keys = new Set();
    addEventListener('keydown', e => keys.add(e.key.toLowerCase()));
    addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));
    let drag = false, lx = 0;
    renderer.domElement.addEventListener('mousedown', e => { drag = true; lx = e.clientX; });
    addEventListener('mouseup', () => drag = false);
    addEventListener('mousemove', e => { if (drag) { yaw -= (e.clientX - lx) * 0.006; lx = e.clientX; } });

    const ray = new THREE.Raycaster();
    const p = new THREE.Vector2();
    renderer.domElement.addEventListener('click', (e) => {
      p.x = (e.clientX / innerWidth) * 2 - 1;
      p.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(p, cam);

      const zHits = ray.intersectObjects(zoneObjects, true);
      if (zHits[0]?.object?.userData?.path) {
        focusZone(zHits[0].object.userData.path);
        return;
      }

      const aHits = ray.intersectObjects(agentPickMeshes, true);
      if (aHits[0]) {
        const root = agents.find(a => a.mesh === aHits[0].object || a.mesh.children.includes(aHits[0].object));
        if (root) {
          selectedAgent = root;
          out.textContent = `${root.id} selected • status:${root.status} • task:${root.task}`;
        }
      }
    });

    const clock = new THREE.Clock();
    const tmp = new THREE.Vector3();

    function tickAgents(dt) {
      for (const a of agents) {
        if (!a.moving) continue;
        if (a.pause > 0) { a.pause -= dt; continue; }

        const dir = tmp.copy(a.target).sub(a.mesh.position);
        dir.y = 0;
        const len = dir.length();

        if (len < 0.5) {
          const nearest = pathNodes.slice().sort((n1, n2) => n1.distanceTo(a.mesh.position) - n2.distanceTo(a.mesh.position))[0];
          const local = pathNodes.filter(n => n.distanceTo(nearest) < 64);
          a.target.copy(local[(Math.random() * local.length) | 0] || pathNodes[(Math.random() * pathNodes.length) | 0]);
          a.pause = Math.random() * 1.0;
          if (Math.random() < 0.08) {
            a.status = STATUS_LIST[(Math.random() * STATUS_LIST.length) | 0];
            a.mesh.children[1].material.color.setHex(STATUS_COLOR[a.status]);
            a.mesh.remove(a.tag);
            a.tag = idLabel(a.id, a.status);
            a.tag.position.set(0, 2.4, 0);
            a.mesh.add(a.tag);
          }
        } else {
          dir.normalize();
          a.mesh.position.addScaledVector(dir, a.speed * dt);
          a.mesh.rotation.y = Math.atan2(dir.x, dir.z);
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      const pan = 30 * dt;
      if (keys.has('w')) { camTarget.x -= pan; camTarget.z -= pan; }
      if (keys.has('s')) { camTarget.x += pan; camTarget.z += pan; }
      if (keys.has('a')) { camTarget.x -= pan; camTarget.z += pan; }
      if (keys.has('d')) { camTarget.x += pan; camTarget.z -= pan; }
      if (keys.has('q')) zoom = Math.min(2.3, zoom + 0.7 * dt);
      if (keys.has('e')) zoom = Math.max(0.55, zoom - 0.7 * dt);

      const dist = 108;
      const desired = new THREE.Vector3(camTarget.x + Math.cos(yaw) * dist, 74 / zoom, camTarget.z + Math.sin(yaw) * dist);
      cam.position.lerp(desired, 0.08);
      cam.lookAt(camLook.x * 0.95 + camTarget.x * 0.05, 0, camLook.z * 0.95 + camTarget.z * 0.05);
      updateCamFrustum();

      tickAgents(dt);

      if (selectedAgent) {
        selectedAgent.mesh.children[0].material.color.setHex(0x111111);
        selectedAgent.mesh.children[1].material.color.setHex(STATUS_COLOR[selectedAgent.status]);
      }

      renderer.render(scene, cam);
    }

    addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
      updateCamFrustum();
    });

    focusZone('/AGENTS/STATUS');
    animate();
  </script>
</body>
</html>
