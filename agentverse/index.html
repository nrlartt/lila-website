<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agentverse Hub</title>
  <style>
    :root {
      --bg: #8d8d8d;
      --panel: rgba(15, 15, 15, 0.78);
      --line: #2a2a2a;
      --text: #f3f3f3;
      --muted: #b8b8b8;
      --accent: #d4d4d4;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #app { position: fixed; inset: 0; }
    #hud {
      position: fixed; top: 12px; left: 12px; z-index: 20;
      background: var(--panel); color: var(--text);
      border: 1px solid #3a3a3a; border-radius: 10px; padding: 10px 12px; width: 360px;
      backdrop-filter: blur(4px);
    }
    #title { font-size: 13px; letter-spacing: .08em; font-weight: 700; }
    #sub { margin-top: 4px; color: var(--muted); font-size: 11px; }
    #cli { display: flex; gap: 8px; margin-top: 10px; }
    #cmd {
      flex: 1; background: #0f0f0f; color: #f5f5f5; border: 1px solid #3b3b3b;
      border-radius: 8px; padding: 8px 10px; font-size: 12px; outline: none;
    }
    #run {
      background: #171717; color: #f3f3f3; border: 1px solid #4a4a4a;
      border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 12px;
    }
    #hint { margin-top: 8px; font-size: 11px; color: #cfcfcf; line-height: 1.4; }
    #log { margin-top: 8px; font-size: 11px; color: #d6d6d6; min-height: 16px; }
    #legend {
      position: fixed; right: 12px; top: 12px; z-index: 20;
      background: var(--panel); color: var(--text); border: 1px solid #3a3a3a;
      border-radius: 10px; padding: 10px; width: 230px; font-size: 11px;
    }
    #legend b { color: #ffffff; }
    .k { color: #e2e2e2; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div id="title">AGENTVERSE HUB</div>
    <div id="sub">command line Ã— metaverse Ã— terminal</div>
    <div id="cli">
      <input id="cmd" placeholder="type: /ACQUIRE or /STARTUP/GUMROAD" />
      <button id="run">ENTER</button>
    </div>
    <div id="hint">WASD: pan â€¢ Q/E: zoom â€¢ drag: rotate â€¢ click zone labels to jump</div>
    <div id="log">System online. 0 agents synced.</div>
  </div>

  <div id="legend">
    <div><b>Nodes</b></div>
    <div class="k">/ACQUIRE /GAME /OPEN /STATS /CHAMPIONSHIP</div>
    <div class="k">/STARTUP/SHIPFAST /STARTUP/GUMROAD</div>
    <div class="k">/STARTUP/TRIMRX /STARTUP/TRUSTMRR /OTHERS</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.167.1/build/three.module.js';

    const app = document.getElementById('app');
    const log = document.getElementById('log');
    const cmdInput = document.getElementById('cmd');
    const runBtn = document.getElementById('run');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x8d8d8d);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = false;
    app.appendChild(renderer.domElement);

    // Isometric camera
    const aspect = innerWidth / innerHeight;
    const frustum = 85;
    const camera = new THREE.OrthographicCamera(
      (-frustum * aspect) / 2,
      (frustum * aspect) / 2,
      frustum / 2,
      -frustum / 2,
      0.1,
      1000
    );
    camera.position.set(78, 72, 78);
    camera.lookAt(0, 0, 0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.82));
    const key = new THREE.DirectionalLight(0xffffff, 0.55);
    key.position.set(50, 80, 30);
    scene.add(key);

    // Infinite-feeling ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1200, 1200),
      new THREE.MeshLambertMaterial({ color: 0x9a9a9a })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const grid = new THREE.GridHelper(300, 60, 0x7d7d7d, 0x8c8c8c);
    grid.position.y = 0.01;
    scene.add(grid);

    const CORRIDOR = { w: 16, color: 0x888888 };
    const ZONE = { w: 28, d: 20, h: 4.8, wall: 0xdadada, floor: 0xcfcfcf, border: 0xb5b5b5 };

    const zones = [
      { path: '/CHAMPIONSHIP', x: -62, z: -32 },
      { path: '/STATS', x: -18, z: -32 },
      { path: '/STARTUP/SHIPFAST', x: 26, z: -32 },
      { path: '/OPEN', x: 70, z: -32 },
      { path: '/ACQUIRE', x: -62, z: 4 },
      { path: '/GAME', x: -18, z: 4 },
      { path: '/STARTUP/GUMROAD', x: 26, z: 4 },
      { path: '/OTHERS', x: 70, z: 4 },
      { path: '/STARTUP/TRUSTMRR', x: 26, z: 40 },
      { path: '/STARTUP/TRIMRX', x: 70, z: 40 }
    ];

    const zoneMap = new Map();
    const labelObjects = [];

    function box(w, h, d, color) {
      return new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color }));
    }

    function makeZone({ path, x, z }) {
      const group = new THREE.Group();
      group.position.set(x, 0, z);

      const floor = box(ZONE.w, 0.2, ZONE.d, ZONE.floor);
      floor.position.y = 0.1;
      group.add(floor);

      const wallL = box(0.9, ZONE.h, ZONE.d, ZONE.wall);
      wallL.position.set(-ZONE.w / 2, ZONE.h / 2, 0);
      const wallR = wallL.clone(); wallR.position.x = ZONE.w / 2;
      const wallB = box(ZONE.w, ZONE.h, 0.9, ZONE.wall);
      wallB.position.set(0, ZONE.h / 2, -ZONE.d / 2);
      [wallL, wallR, wallB].forEach(w => group.add(w));

      const line = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(ZONE.w, ZONE.h, ZONE.d)),
        new THREE.LineBasicMaterial({ color: ZONE.border })
      );
      line.position.y = ZONE.h / 2;
      group.add(line);

      const label = makeLabel(path);
      label.position.set(0, ZONE.h + 1.8, -ZONE.d / 2 + 1.2);
      label.userData.path = path;
      group.add(label);
      labelObjects.push(label);

      scene.add(group);
      zoneMap.set(path.toUpperCase(), { x, z });
    }

    function makeLabel(text) {
      const c = document.createElement('canvas');
      c.width = 768;
      c.height = 160;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#131313';
      ctx.fillRect(0, 0, c.width, c.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 72px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, c.width / 2, c.height / 2 + 2);

      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: false });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(15, 3.1), mat);
      mesh.rotation.x = -Math.PI / 8;
      return mesh;
    }

    // Corridors (symmetrical)
    const corridorMat = new THREE.MeshLambertMaterial({ color: CORRIDOR.color });
    const central = new THREE.Mesh(new THREE.BoxGeometry(CORRIDOR.w, 0.12, 125), corridorMat);
    central.position.set(4, 0.06, 6);
    scene.add(central);

    const rowA = new THREE.Mesh(new THREE.BoxGeometry(170, 0.12, CORRIDOR.w), corridorMat);
    rowA.position.set(4, 0.06, -32);
    const rowB = rowA.clone(); rowB.position.z = 4;
    const rowC = new THREE.Mesh(new THREE.BoxGeometry(126, 0.12, CORRIDOR.w), corridorMat);
    rowC.position.set(39, 0.06, 40);
    scene.add(rowA, rowB, rowC);

    zones.forEach(makeZone);

    // Agent generation
    const skin = [0xf2d3bc, 0xd8a47f, 0x8b5d3b, 0x5b3d2a, 0xc68f6f];
    const cloth = [0x1f2937, 0x4b5563, 0x111827, 0x374151, 0x334155, 0x6b7280, 0x4c1d95, 0x0f766e];
    const flags = ['ðŸ‡ºðŸ‡¸','ðŸ‡¯ðŸ‡µ','ðŸ‡¹ðŸ‡·','ðŸ‡«ðŸ‡·','ðŸ‡©ðŸ‡ª','ðŸ‡¬ðŸ‡§','ðŸ‡¨ðŸ‡¦','ðŸ‡°ðŸ‡·','ðŸ‡®ðŸ‡¹','ðŸ‡§ðŸ‡·','ðŸ‡®ðŸ‡³','ðŸ‡ªðŸ‡¸','ðŸ‡³ðŸ‡±'];

    const corridorNodes = [
      new THREE.Vector3(-80, 0, -32), new THREE.Vector3(4, 0, -32), new THREE.Vector3(90, 0, -32),
      new THREE.Vector3(-80, 0, 4), new THREE.Vector3(4, 0, 4), new THREE.Vector3(90, 0, 4),
      new THREE.Vector3(4, 0, -56), new THREE.Vector3(4, 0, 64), new THREE.Vector3(39, 0, 40), new THREE.Vector3(90, 0, 40)
    ];

    function makeFlagSprite(text) {
      const c = document.createElement('canvas');
      c.width = 96; c.height = 48;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      roundRect(ctx, 0, 2, 95, 44, 10); ctx.fill();
      ctx.font = '28px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 48, 24);
      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sp = new THREE.Sprite(mat);
      sp.scale.set(3.2, 1.6, 1);
      return sp;
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function makeAgent(pos, moving = false) {
      const g = new THREE.Group();

      const torso = box(1.05, 1.4, 0.62, cloth[(Math.random()*cloth.length)|0]);
      torso.position.y = 1.25;
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.38, 12, 12), new THREE.MeshLambertMaterial({ color: skin[(Math.random()*skin.length)|0] }));
      head.position.y = 2.27;
      const legL = box(0.28, 0.9, 0.28, 0x1f2937); legL.position.set(-0.2,0.45,0);
      const legR = legL.clone(); legR.position.x = 0.2;
      g.add(torso, head, legL, legR);

      const flag = makeFlagSprite(flags[(Math.random()*flags.length)|0]);
      flag.position.set(0, 3.25, 0);
      g.add(flag);

      g.position.copy(pos);
      scene.add(g);

      return {
        mesh: g,
        moving,
        targetNode: corridorNodes[(Math.random()*corridorNodes.length)|0].clone(),
        speed: 1.5 + Math.random() * 0.9,
        wait: Math.random() * 2,
      };
    }

    const agents = [];

    // Standing agents in zones
    zones.forEach((z, i) => {
      const count = i % 2 === 0 ? 3 : 2;
      for (let n = 0; n < count; n++) {
        const px = z.x - 6 + Math.random() * 12;
        const pz = z.z - 4 + Math.random() * 8;
        agents.push(makeAgent(new THREE.Vector3(px, 0, pz), false));
      }
    });

    // Corridor walkers
    for (let i = 0; i < 22; i++) {
      const node = corridorNodes[(Math.random()*corridorNodes.length)|0];
      const jitter = new THREE.Vector3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2);
      agents.push(makeAgent(node.clone().add(jitter), true));
    }

    let yaw = Math.PI / 4;
    let zoom = 1;
    const keys = new Set();
    addEventListener('keydown', e => keys.add(e.key.toLowerCase()));
    addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    let dragging = false;
    let lx = 0;
    renderer.domElement.addEventListener('mousedown', (e) => { dragging = true; lx = e.clientX; });
    addEventListener('mouseup', () => dragging = false);
    addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lx;
      lx = e.clientX;
      yaw -= dx * 0.006;
    });

    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    renderer.domElement.addEventListener('click', (e) => {
      pointer.x = (e.clientX / innerWidth) * 2 - 1;
      pointer.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(labelObjects, true);
      if (hits[0]?.object?.userData?.path) {
        executeCommand(hits[0].object.userData.path);
      }
    });

    function executeCommand(raw) {
      const cmd = String(raw || '').trim().toUpperCase();
      if (!cmd) return;
      const node = zoneMap.get(cmd);
      if (!node) {
        log.textContent = `Unknown node: ${cmd}`;
        return;
      }
      cameraTarget.set(node.x + 24, 72, node.z + 24);
      lookTarget.set(node.x, 0, node.z);
      log.textContent = `Jumped to ${cmd}`;
    }

    runBtn.onclick = () => executeCommand(cmdInput.value);
    cmdInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') executeCommand(cmdInput.value);
    });

    const cameraTarget = camera.position.clone();
    const lookTarget = new THREE.Vector3(0,0,0);
    const tmp = new THREE.Vector3();
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      // camera controls
      const pan = 28 * dt;
      if (keys.has('w')) { cameraTarget.x -= pan; cameraTarget.z -= pan; }
      if (keys.has('s')) { cameraTarget.x += pan; cameraTarget.z += pan; }
      if (keys.has('a')) { cameraTarget.x -= pan; cameraTarget.z += pan; }
      if (keys.has('d')) { cameraTarget.x += pan; cameraTarget.z -= pan; }
      if (keys.has('q')) zoom = Math.min(2, zoom + dt * 0.8);
      if (keys.has('e')) zoom = Math.max(0.55, zoom - dt * 0.8);

      const dist = 100;
      camera.position.lerp(new THREE.Vector3(
        cameraTarget.x + Math.cos(yaw) * dist,
        72 / zoom,
        cameraTarget.z + Math.sin(yaw) * dist
      ), 0.08);
      tmp.lerpVectors(lookTarget, cameraTarget, 0.02);
      camera.lookAt(tmp.x, 0, tmp.z);

      const fr = 85 / zoom;
      const asp = innerWidth / innerHeight;
      camera.left = (-fr * asp) / 2;
      camera.right = (fr * asp) / 2;
      camera.top = fr / 2;
      camera.bottom = -fr / 2;
      camera.updateProjectionMatrix();

      // agent movement (semi-random purposeful)
      let movers = 0;
      for (const a of agents) {
        if (!a.moving) continue;
        movers++;
        if (a.wait > 0) { a.wait -= dt; continue; }

        const dir = tmp.copy(a.targetNode).sub(a.mesh.position);
        dir.y = 0;
        const len = dir.length();

        if (len < 0.6) {
          // choose connected-ish next node
          const nearest = corridorNodes
            .slice()
            .sort((n1, n2) => n1.distanceTo(a.mesh.position) - n2.distanceTo(a.mesh.position))[0];
          const options = corridorNodes
            .filter(n => n.distanceTo(nearest) < 60)
            .sort(() => Math.random() - 0.5);
          a.targetNode.copy(options[0] || corridorNodes[(Math.random()*corridorNodes.length)|0]);
          a.wait = Math.random() * 1.4;
        } else {
          dir.normalize();
          a.mesh.position.addScaledVector(dir, a.speed * dt);
          a.mesh.rotation.y = Math.atan2(dir.x, dir.z);
        }
      }

      log.textContent = `System online. ${agents.length} agents synced â€¢ ${movers} active walkers.`;
      renderer.render(scene, camera);
    }

    addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>
