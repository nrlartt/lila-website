<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AGENTVERSE</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; color: #fff; font-family: Inter, system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    .hud {
      position: fixed; top: 12px; left: 12px; z-index: 20;
      background: rgba(0,0,0,.62); border: 1px solid #2e2e3a; border-radius: 10px;
      padding: 12px; width: min(420px, calc(100vw - 24px));
      backdrop-filter: blur(8px);
    }
    .title { font-weight: 700; letter-spacing: .08em; }
    .status { margin-top: 8px; font-size: 12px; color: #c9c9d4; }
    .button { margin-top: 10px; padding: 8px 12px; background: #fff; color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; }
    .button:disabled { opacity: .7; cursor: wait; }
    .sub { margin-top: 8px; font-size: 12px; color: #aaa; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
    .card { border: 1px solid #2f2f3d; border-radius: 8px; padding: 8px; background: rgba(255,255,255,.02); }
    .card .label { font-size: 10px; color: #8a8aa0; text-transform: uppercase; letter-spacing: .08em; }
    .card .value { font-size: 13px; color: #e7e7ff; margin-top: 2px; }
    .agents { margin: 6px 0 0; padding-left: 18px; max-height: 130px; overflow: auto; font-size: 12px; color: #d9d9e6; }
    .crosshair {
      position: fixed; left: 50%; top: 50%; width: 12px; height: 12px;
      transform: translate(-50%, -50%); border: 1px solid rgba(255,255,255,.45);
      border-radius: 99px; pointer-events: none; z-index: 15;
    }
    a { color: #c084fc; text-decoration: none; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="title">AGENTVERSE MVP</div>
    <div id="status" class="status">Status: disconnected</div>
    <button id="connect" class="button">Connect Wallet</button>
    <div class="sub">Movement: WASD · Look: Mouse · Sprint: Shift</div>
    <div class="sub">Onboarding Skill: <a href="/skill.md">/skill.md</a></div>

    <div class="grid">
      <div class="card"><div class="label">Active Agents</div><div id="agentCount" class="value">0</div></div>
    </div>

    <div class="sub" style="margin-top:10px;">Online entities</div>
    <ul id="agents" class="agents"></ul>
  </div>

  <div class="crosshair"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import { BrowserProvider } from 'https://esm.sh/ethers@6.13.2';
    import Privy, { LocalStorage as PrivyLocalStorage } from 'https://esm.sh/@privy-io/js-sdk-core@0.60.1';

    const API_BASE = '/agentverse-api';
    const WS_URL = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/agentverse-ws`;
    const CHAIN_ID = 8453;
    const DOMAIN = 'lilagent.xyz';
    const WORLD_ID = 'lobby';
    const PRIVY_APP_ID = window.__PRIVY_APP_ID__ || localStorage.getItem('PRIVY_APP_ID') || 'cmlrxgwh802rd0bkztv4iceu2';
    const PRIVY_CLIENT_ID = window.__PRIVY_CLIENT_ID__ || localStorage.getItem('PRIVY_CLIENT_ID') || 'cmhuq6qqv00dfi60b72eee6bn';

    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connect');
    const agentsEl = document.getElementById('agents');
    const agentCountEl = document.getElementById('agentCount');
    const app = document.getElementById('app');

    function setStatus(text) { statusEl.textContent = `Status: ${text}`; }

    // Scene bootstrap
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x89b7ff);
    scene.fog = new THREE.Fog(0x89b7ff, 90, 340);

    const camera = new THREE.PerspectiveCamera(76, innerWidth / innerHeight, 0.1, 1200);
    camera.position.set(0, 1.7, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xeef7ff, 0x5b6d78, 1.1));
    const sun = new THREE.DirectionalLight(0xffffff, 1.15);
    sun.position.set(120, 180, 70);
    sun.castShadow = true;
    scene.add(sun);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(900, 900),
      new THREE.MeshStandardMaterial({ color: 0x4d7f42, roughness: 0.96, metalness: 0.03 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Roads
    function makeRoad(w, h, x, z) {
      const road = new THREE.Mesh(
        new THREE.PlaneGeometry(w, h),
        new THREE.MeshStandardMaterial({ color: 0x2f2f34, roughness: 0.92 })
      );
      road.rotation.x = -Math.PI / 2;
      road.position.set(x, 0.02, z);
      scene.add(road);
    }
    makeRoad(260, 14, 0, 0);
    makeRoad(14, 260, 0, 0);

    // Water lake
    const lake = new THREE.Mesh(
      new THREE.CircleGeometry(42, 64),
      new THREE.MeshStandardMaterial({ color: 0x2d7cff, transparent: true, opacity: 0.72, roughness: 0.2, metalness: 0.1 })
    );
    lake.rotation.x = -Math.PI / 2;
    lake.position.set(-95, 0.04, 85);
    scene.add(lake);

    // Trees
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6e4f34, roughness: 0.98 });
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x2a7f33, roughness: 0.9 });
    function addTree(x, z, s = 1) {
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.35*s, 0.48*s, 3.5*s, 8), trunkMat);
      trunk.position.set(x, 1.75*s, z);
      trunk.castShadow = true;
      const crown = new THREE.Mesh(new THREE.SphereGeometry(2.4*s, 12, 10), leafMat);
      crown.position.set(x, 4.6*s, z);
      crown.castShadow = true;
      treeGroup.add(trunk, crown);
    }
    for (let i = 0; i < 140; i++) {
      const x = (Math.random() - 0.5) * 560;
      const z = (Math.random() - 0.5) * 560;
      if (Math.abs(x) < 22 || Math.abs(z) < 22) continue;
      addTree(x, z, 0.8 + Math.random() * 0.8);
    }

    // Houses
    const houseGroup = new THREE.Group();
    scene.add(houseGroup);
    function addHouse(x, z, w = 8, d = 7, h = 5) {
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        new THREE.MeshStandardMaterial({ color: 0xe7e1d7, roughness: 0.92 })
      );
      body.position.set(x, h/2, z);
      body.castShadow = true;
      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(Math.max(w, d) * 0.74, 3.2, 4),
        new THREE.MeshStandardMaterial({ color: 0x993333, roughness: 0.9 })
      );
      roof.position.set(x, h + 1.8, z);
      roof.rotation.y = Math.PI * 0.25;
      roof.castShadow = true;
      houseGroup.add(body, roof);
    }
    const block = [-60, -40, -20, 20, 40, 60];
    for (const x of block) {
      for (const z of block) {
        if (Math.abs(x) < 25 && Math.abs(z) < 25) continue;
        if (Math.random() > 0.45) addHouse(x * 1.8, z * 1.8, 7 + Math.random() * 3, 6 + Math.random() * 3, 4 + Math.random() * 2);
      }
    }

    // Humans (ambient citizens)
    const citizens = [];
    function spawnCitizen(i) {
      const group = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.3, 0.8, 4, 8),
        new THREE.MeshStandardMaterial({ color: 0xdddddd })
      );
      body.castShadow = true;
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.24, 10, 10),
        new THREE.MeshStandardMaterial({ color: 0xffd6b0 })
      );
      head.position.y = 0.95;
      group.add(body, head);
      group.position.set((Math.random() - 0.5) * 140, 1.05, (Math.random() - 0.5) * 140);
      scene.add(group);
      citizens.push({ mesh: group, angle: Math.random() * Math.PI * 2, radius: 8 + Math.random() * 32, speed: 0.12 + Math.random() * 0.22, centerX: group.position.x, centerZ: group.position.z });
    }
    for (let i = 0; i < 28; i++) spawnCitizen(i);

    // Agent entities (remote + simulated)
    const entities = new Map();
    const entityLabels = new Map();
    function createAgentMesh(color = 0x6ee7ff) {
      const group = new THREE.Group();
      const core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.42, 1), new THREE.MeshStandardMaterial({ color, emissive: 0x11243a, roughness: 0.35, metalness: 0.4 }));
      const ring = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.05, 12, 40), new THREE.MeshStandardMaterial({ color: 0xb794f6, roughness: 0.45 }));
      ring.rotation.x = Math.PI * 0.45;
      group.add(core, ring);
      return group;
    }
    function upsertEntity(id, x, y, z, color = 0x6ee7ff) {
      let entry = entities.get(id);
      if (!entry) {
        const mesh = createAgentMesh(color);
        scene.add(mesh);
        const li = document.createElement('li');
        li.id = `agent-${id}`;
        li.textContent = id;
        agentsEl.appendChild(li);
        entities.set(id, { mesh, target: new THREE.Vector3(x, y, z) });
      }
      entry = entities.get(id);
      entry.target.set(x, y, z);
      updateAgentCount();
    }
    function updateAgentCount() {
      agentCountEl.textContent = String(entities.size);
    }

    // Simulated active agents (always visible)
    const simulatedAgents = [];
    for (let i = 1; i <= 12; i++) {
      const id = `agent-bot-${String(i).padStart(2, '0')}`;
      upsertEntity(id, (Math.random() - 0.5) * 80, 2, (Math.random() - 0.5) * 80, 0x22d3ee);
      simulatedAgents.push({ id, angle: Math.random() * Math.PI * 2, radius: 8 + Math.random() * 40, speed: 0.18 + Math.random() * 0.2, centerX: (Math.random() - 0.5) * 80, centerZ: (Math.random() - 0.5) * 80 });
    }

    // Player controls
    const keys = {};
    let yaw = 0;
    let pitch = 0;
    let pointerLocked = false;

    addEventListener('keydown', (e) => keys[e.code] = true);
    addEventListener('keyup', (e) => keys[e.code] = false);

    renderer.domElement.addEventListener('click', () => {
      if (!pointerLocked) renderer.domElement.requestPointerLock();
    });
    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
    });
    document.addEventListener('mousemove', (e) => {
      if (!pointerLocked) return;
      yaw -= e.movementX * 0.0022;
      pitch -= e.movementY * 0.0022;
      pitch = Math.max(-1.2, Math.min(1.2, pitch));
    });

    // Network helpers
    let ws = null;
    let presenceTimer = null;

    function connectWs(wsToken = '') {
      if (!wsToken) {
        setStatus('wallet connected · local mode');
        return;
      }

      ws = new WebSocket(WS_URL);
      ws.onopen = () => {
        ws.send(JSON.stringify({ type: 'hello', wsToken }));
        setStatus('wallet connected · websocket connected');
      };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'presence' && msg.userId) {
            upsertEntity(msg.userId, Number(msg.x ?? 0), Number(msg.y ?? 2), Number(msg.z ?? 0), 0x7dd3fc);
          }
        } catch {}
      };
      ws.onclose = () => {
        setStatus('wallet connected · websocket disconnected');
      };

      if (presenceTimer) clearInterval(presenceTimer);
      presenceTimer = setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        ws.send(JSON.stringify({ type: 'heartbeat', ts: Date.now() }));
        ws.send(JSON.stringify({
          type: 'presence',
          worldId: WORLD_ID,
          x: Number(camera.position.x.toFixed(3)),
          y: Number(camera.position.y.toFixed(3)),
          z: Number(camera.position.z.toFixed(3))
        }));
      }, 2500);
    }

    async function connectWithPrivy() {
      if (!PRIVY_CLIENT_ID || PRIVY_CLIENT_ID.startsWith('REPLACE_')) {
        throw new Error('Privy is not configured. Set window.__PRIVY_CLIENT_ID__ (or localStorage.PRIVY_CLIENT_ID)');
      }
      if (!window.ethereum) {
        throw new Error('No injected wallet found for Privy SIWE flow');
      }

      const provider = new BrowserProvider(window.ethereum);
      const network = await provider.getNetwork();
      if (Number(network.chainId) !== CHAIN_ID) {
        const hexChainId = `0x${CHAIN_ID.toString(16)}`;
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: hexChainId }] });
      }

      const signer = await provider.getSigner();
      const address = await signer.getAddress();

      const privyConfig = {
        clientId: PRIVY_CLIENT_ID,
        storage: new PrivyLocalStorage()
      };
      if (PRIVY_APP_ID && PRIVY_APP_ID !== PRIVY_CLIENT_ID) {
        privyConfig.appId = PRIVY_APP_ID;
      }

      const privy = new Privy(privyConfig);
      await privy.initialize();

      const wallet = {
        address,
        chainId: `eip155:${CHAIN_ID}`,
        walletClientType: 'metamask',
        connectorType: 'injected'
      };

      const { message } = await privy.auth.siwe.init(wallet, DOMAIN, `${location.origin}/agentverse`);
      const signature = await signer.signMessage(message);
      await privy.auth.siwe.loginWithSiwe(signature, wallet, message);

      return { address, wsToken: '' };
    }

    async function connectWithInjectedFallback() {
      if (!window.ethereum) {
        throw new Error('No wallet provider found');
      }
      const provider = new BrowserProvider(window.ethereum);
      const network = await provider.getNetwork();
      if (Number(network.chainId) !== CHAIN_ID) {
        const hexChainId = `0x${CHAIN_ID.toString(16)}`;
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: hexChainId }] });
      }
      const signer = await provider.getSigner();
      const address = await signer.getAddress();
      return { address, wsToken: '' };
    }

    connectBtn.onclick = async () => {
      try {
        connectBtn.disabled = true;
        setStatus('connecting wallet via Privy');

        const result = await connectWithPrivy();
        upsertEntity('you', camera.position.x, 2, camera.position.z, 0xa855f7);
        connectWs(result.wsToken || '');
      } catch (err) {
        console.error('Privy wallet connection failed:', err);
        setStatus(`Privy error: ${err?.message || 'wallet connection error'}`);
      } finally {
        connectBtn.disabled = false;
      }
    };

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Player camera
      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;

      const sprint = keys.ShiftLeft ? 1.9 : 1;
      const speed = 7.0 * sprint;
      const move = new THREE.Vector3();
      if (keys.KeyW) move.z -= 1;
      if (keys.KeyS) move.z += 1;
      if (keys.KeyA) move.x -= 1;
      if (keys.KeyD) move.x += 1;
      move.normalize();

      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).setY(0).normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion).setY(0).normalize();
      camera.position.addScaledVector(forward, move.z * speed * dt);
      camera.position.addScaledVector(right, move.x * speed * dt);
      camera.position.y = 1.7;

      // Keep within map
      camera.position.x = Math.max(-320, Math.min(320, camera.position.x));
      camera.position.z = Math.max(-320, Math.min(320, camera.position.z));

      // Citizens movement
      for (const c of citizens) {
        c.angle += c.speed * dt;
        c.mesh.position.x = c.centerX + Math.cos(c.angle) * c.radius;
        c.mesh.position.z = c.centerZ + Math.sin(c.angle) * c.radius;
        c.mesh.rotation.y = -c.angle;
      }

      // Simulated agents movement
      for (const s of simulatedAgents) {
        s.angle += s.speed * dt;
        upsertEntity(
          s.id,
          s.centerX + Math.cos(s.angle) * s.radius,
          2.0 + Math.sin(s.angle * 2) * 0.25,
          s.centerZ + Math.sin(s.angle) * s.radius,
          0x22d3ee
        );
      }

      // Smooth entity interpolation + spin
      for (const [, entry] of entities) {
        entry.mesh.position.lerp(entry.target, 0.14);
        entry.mesh.rotation.y += dt * 0.8;
      }

      renderer.render(scene, camera);
    }

    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
